module.exports=[55994,e=>{"use strict";e.s(["handler",()=>b,"patchFetch",()=>W,"routeModule",()=>B,"serverHooks",()=>k,"workAsyncStorage",()=>U,"workUnitAsyncStorage",()=>K],55994);var t=e.i(47909),r=e.i(74017),o=e.i(96250),n=e.i(59756),s=e.i(61916),a=e.i(69741),i=e.i(16795),l=e.i(87718),c=e.i(95169),d=e.i(47587),u=e.i(66012),E=e.i(70101),p=e.i(26937),O=e.i(10372),N=e.i(93695);e.i(52474);var T=e.i(220);e.s(["POST",()=>I,"maxDuration",()=>v,"runtime",()=>y],3290);var C=e.i(89171),g=e.i(26500),h=function(e){return e.USER_REGISTERED="USER_REGISTERED",e.USER_DELETED="USER_DELETED",e.CONNECTION_ATTEMPTED="CONNECTION_ATTEMPTED",e.CONNECTION_ADDED="CONNECTION_ADDED",e.CONNECTION_DELETED="CONNECTION_DELETED",e.CONNECTION_BROKEN="CONNECTION_BROKEN",e.CONNECTION_FIXED="CONNECTION_FIXED",e.CONNECTION_UPDATED="CONNECTION_UPDATED",e.CONNECTION_FAILED="CONNECTION_FAILED",e.NEW_ACCOUNT_AVAILABLE="NEW_ACCOUNT_AVAILABLE",e.ACCOUNT_REMOVED="ACCOUNT_REMOVED",e.ACCOUNT_TRANSACTIONS_INITIAL_UPDATE="ACCOUNT_TRANSACTIONS_INITIAL_UPDATE",e.ACCOUNT_TRANSACTIONS_UPDATED="ACCOUNT_TRANSACTIONS_UPDATED",e.ACCOUNT_HOLDINGS_UPDATED="ACCOUNT_HOLDINGS_UPDATED",e.TRADES_PLACED="TRADES_PLACED",e}({});async function D(e,t,r,o,n,s=5){try{let a=(0,g.createServiceRoleClient)(),i=new Date(new Date(n).getTime()-6e4*s).toISOString(),{data:l,error:c}=await a.from("leader_trades").select("id").eq("leader_id",e).eq("symbol",t).eq("action",r.toLowerCase()).eq("quantity",o).gte("detected_at",i).lte("detected_at",n).limit(1);if(c)return console.error("[WEBHOOK] Error checking for duplicate trades:",c),!1;return l&&l.length>0}catch(e){return console.error("[WEBHOOK] Error in checkTradeExists:",e),!1}}async function _(e,t,r){try{let o=(0,g.createServiceRoleClient)(),n=new Date().toISOString();if(await D(e,r.symbol,r.action,r.quantity,n,5))return console.log(`[WEBHOOK] Duplicate trade detected for ${e} - ${r.symbol} ${r.action} ${r.quantity}`),null;let s={leader_id:e,account_id:t,symbol:r.symbol,action:r.action.toLowerCase(),quantity:r.quantity,price:r.price||null,order_type:r.orderType||"market",asset_type:r.assetType||"stock",option_type:r.optionType||null,strike_price:r.strikePrice||null,expiration_date:r.expirationDate||null,contracts:r.contracts||null,order_id:r.orderId||null,processed:!1,is_exit:!1,detected_at:n},{data:a,error:i}=await o.from("leader_trades").insert(s).select("id").single();if(i)return console.error("[WEBHOOK] Error creating trade record:",i),null;return console.log(`[WEBHOOK] Trade created successfully: ${e} - ${r.symbol} ${r.action} ${r.quantity}`,{tradeId:a?.id}),a?.id||null}catch(e){return console.error("[WEBHOOK] Error in createTradeFromWebhook:",e),null}}async function A(e){try{let t=(0,g.createServiceRoleClient)(),{data:r,error:o}=await t.from("users").select("id, full_name").eq("snaptrade_user_id",e).eq("role","leader").single();if(o){if("PGRST116"===o.code)return console.log(`[WEBHOOK] No leader found for SnapTrade user ${e}`),null;return console.error("[WEBHOOK] Error fetching leader:",o),null}return r}catch(e){return console.error("[WEBHOOK] Error in getLeaderBySnapTradeUserId:",e),null}}async function R(e,t){let r={processed:0,skipped:0,errors:0};try{let o=e.userId,n=await A(o);if(!n)return console.log(`[WEBHOOK] Skipping trades - leader not found for user ${o}`),r.skipped=t.length,r;console.log(`[WEBHOOK] Processing ${t.length} trades for leader ${n.full_name} (${n.id})`);let s=e.details?.accountId||e.details?.account_id;for(let e of(s||console.warn("[WEBHOOK] No account ID in webhook details, using default"),t))try{await _(n.id,s||"unknown",e)?r.processed++:r.skipped++}catch(e){console.error("[WEBHOOK] Error processing trade:",e),r.errors++}return console.log("[WEBHOOK] Trade processing complete:",r),r}catch(e){return console.error("[WEBHOOK] Error in processTradesPlacedEvent:",e),r.errors=t.length,r}}async function f(e){try{let t=e.userId,r=await A(t);if(!r)return void console.log(`[WEBHOOK] Skipping holdings update - leader not found for user ${t}`);console.log(`[WEBHOOK] Holdings updated for leader ${r.full_name} (${r.id})`,e.details)}catch(e){console.error("[WEBHOOK] Error in processAccountHoldingsUpdatedEvent:",e)}}let y="nodejs",v=60;async function I(e){try{let t,r=process.env.SNAPTRADE_WEBHOOK_SECRET;if(!r)return console.error("[WEBHOOK] SNAPTRADE_WEBHOOK_SECRET is not configured"),C.NextResponse.json({success:!1,error:"Webhook secret not configured"},{status:500});let o=await e.text();if(!function(e,t,r){try{if(JSON.parse(e).webhookSecret!==t)return console.error("[WEBHOOK] Invalid webhook secret"),!1;return!0}catch(e){return console.error("[WEBHOOK] Error verifying webhook:",e),!1}}(o,r))return console.error("[WEBHOOK] Invalid webhook signature or secret"),C.NextResponse.json({success:!1,error:"Invalid webhook signature"},{status:401});try{t=JSON.parse(o)}catch(e){return console.error("[WEBHOOK] Failed to parse webhook payload:",e),C.NextResponse.json({success:!1,error:"Invalid JSON payload"},{status:400})}switch(console.log(`[WEBHOOK] Received ${t.eventType} event`,{webhookId:t.webhookId,userId:t.userId,timestamp:t.eventTimestamp}),t.eventType){case h.TRADES_PLACED:return await m(t);case h.ACCOUNT_HOLDINGS_UPDATED:return await w(t);case h.CONNECTION_ADDED:return await S(t);case h.CONNECTION_DELETED:return await H(t);case h.CONNECTION_FAILED:return await x(t);default:return console.log(`[WEBHOOK] Event type '${t.eventType}' received but not processed`),C.NextResponse.json({success:!0,message:"Event received and acknowledged",eventType:t.eventType})}}catch(e){return console.error("[WEBHOOK] Unexpected error in webhook handler:",e),C.NextResponse.json({success:!1,error:e instanceof Error?e.message:"Unknown error"},{status:500})}}async function m(e){try{console.log("[WEBHOOK] Processing TRADES_PLACED event");let t=[];if(e.details&&(Array.isArray(e.details.trades)?t=e.details.trades:e.details.symbol&&e.details.action&&(t=[{symbol:e.details.symbol,action:e.details.action.toUpperCase(),quantity:e.details.quantity||1,price:e.details.price,orderType:e.details.orderType,assetType:e.details.assetType,orderId:e.details.orderId,timestamp:e.details.timestamp}])),0===t.length)return console.warn("[WEBHOOK] No trades found in TRADES_PLACED event details"),C.NextResponse.json({success:!0,message:"No trades to process",eventType:h.TRADES_PLACED});console.log(`[WEBHOOK] Processing ${t.length} trades from TRADES_PLACED event`);let r=await R(e,t);return C.NextResponse.json({success:!0,message:"Trades processed successfully",eventType:h.TRADES_PLACED,result:r})}catch(e){return console.error("[WEBHOOK] Error handling TRADES_PLACED event:",e),C.NextResponse.json({success:!1,error:e instanceof Error?e.message:"Failed to process trades"},{status:500})}}async function w(e){try{return console.log("[WEBHOOK] Processing ACCOUNT_HOLDINGS_UPDATED event"),await f(e),C.NextResponse.json({success:!0,message:"Holdings update processed",eventType:h.ACCOUNT_HOLDINGS_UPDATED})}catch(e){return console.error("[WEBHOOK] Error handling ACCOUNT_HOLDINGS_UPDATED event:",e),C.NextResponse.json({success:!1,error:e instanceof Error?e.message:"Failed to process holdings update"},{status:500})}}async function S(e){try{return console.log("[WEBHOOK] Brokerage connection added for user:",e.userId,{details:e.details}),C.NextResponse.json({success:!0,message:"Connection logged",eventType:h.CONNECTION_ADDED})}catch(e){return console.error("[WEBHOOK] Error handling CONNECTION_ADDED event:",e),C.NextResponse.json({success:!1,error:e instanceof Error?e.message:"Failed to handle connection event"},{status:500})}}async function H(e){try{return console.log("[WEBHOOK] Brokerage connection deleted for user:",e.userId,{details:e.details}),C.NextResponse.json({success:!0,message:"Disconnection logged",eventType:h.CONNECTION_DELETED})}catch(e){return console.error("[WEBHOOK] Error handling CONNECTION_DELETED event:",e),C.NextResponse.json({success:!1,error:e instanceof Error?e.message:"Failed to handle disconnection event"},{status:500})}}async function x(e){try{return console.warn("[WEBHOOK] Brokerage connection failed for user:",e.userId,{details:e.details}),C.NextResponse.json({success:!0,message:"Connection failure logged",eventType:h.CONNECTION_FAILED})}catch(e){return console.error("[WEBHOOK] Error handling CONNECTION_FAILED event:",e),C.NextResponse.json({success:!1,error:e instanceof Error?e.message:"Failed to handle connection failure"},{status:500})}}var P=e.i(3290);let B=new t.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/webhooks/snaptrade/route",pathname:"/api/webhooks/snaptrade",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/webhooks/snaptrade/route.ts",nextConfigOutput:"",userland:P}),{workAsyncStorage:U,workUnitAsyncStorage:K,serverHooks:k}=B;function W(){return(0,o.patchFetch)({workAsyncStorage:U,workUnitAsyncStorage:K})}async function b(e,t,o){var C;let g="/api/webhooks/snaptrade/route";g=g.replace(/\/index$/,"")||"/";let h=await B.prepare(e,t,{srcPage:g,multiZoneDraftMode:!1});if(!h)return t.statusCode=400,t.end("Bad Request"),null==o.waitUntil||o.waitUntil.call(o,Promise.resolve()),null;let{buildId:D,params:_,nextConfig:A,isDraftMode:R,prerenderManifest:f,routerServerContext:y,isOnDemandRevalidate:v,revalidateOnlyGenerated:I,resolvedPathname:m}=h,w=(0,a.normalizeAppPath)(g),S=!!(f.dynamicRoutes[w]||f.routes[m]);if(S&&!R){let e=!!f.routes[m],t=f.dynamicRoutes[w];if(t&&!1===t.fallback&&!e)throw new N.NoFallbackError}let H=null;!S||B.isDev||R||(H="/index"===(H=m)?"/":H);let x=!0===B.isDev||!S,P=S&&!x,U=e.method||"GET",K=(0,s.getTracer)(),k=K.getActiveScopeSpan(),W={params:_,prerenderManifest:f,renderOpts:{experimental:{cacheComponents:!!A.experimental.cacheComponents,authInterrupts:!!A.experimental.authInterrupts},supportsDynamicResponse:x,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:null==(C=A.experimental)?void 0:C.cacheLife,isRevalidate:P,waitUntil:o.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,o)=>B.onRequestError(e,t,o,y)},sharedContext:{buildId:D}},b=new i.NodeNextRequest(e),L=new i.NodeNextResponse(t),q=l.NextRequestAdapter.fromNodeNextRequest(b,(0,l.signalFromNodeResponse)(t));try{let a=async r=>B.handle(q,W).finally(()=>{if(!r)return;r.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let o=K.getRootSpanAttributes();if(!o)return;if(o.get("next.span_type")!==c.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${o.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let n=o.get("next.route");if(n){let e=`${U} ${n}`;r.setAttributes({"next.route":n,"http.route":n,"next.span_name":e}),r.updateName(e)}else r.updateName(`${U} ${e.url}`)}),i=async s=>{var i,l;let c=async({previousCacheEntry:r})=>{try{if(!(0,n.getRequestMeta)(e,"minimalMode")&&v&&I&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let i=await a(s);e.fetchMetrics=W.renderOpts.fetchMetrics;let l=W.renderOpts.pendingWaitUntil;l&&o.waitUntil&&(o.waitUntil(l),l=void 0);let c=W.renderOpts.collectedTags;if(!S)return await (0,u.sendResponse)(b,L,i,W.renderOpts.pendingWaitUntil),null;{let e=await i.blob(),t=(0,E.toNodeOutgoingHttpHeaders)(i.headers);c&&(t[O.NEXT_CACHE_TAGS_HEADER]=c),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==W.renderOpts.collectedRevalidate&&!(W.renderOpts.collectedRevalidate>=O.INFINITE_CACHE)&&W.renderOpts.collectedRevalidate,o=void 0===W.renderOpts.collectedExpire||W.renderOpts.collectedExpire>=O.INFINITE_CACHE?void 0:W.renderOpts.collectedExpire;return{value:{kind:T.CachedRouteKind.APP_ROUTE,status:i.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:o}}}}catch(t){throw(null==r?void 0:r.isStale)&&await B.onRequestError(e,t,{routerKind:"App Router",routePath:g,routeType:"route",revalidateReason:(0,d.getRevalidateReason)({isRevalidate:P,isOnDemandRevalidate:v})},y),t}},N=await B.handleResponse({req:e,nextConfig:A,cacheKey:H,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:f,isRoutePPREnabled:!1,isOnDemandRevalidate:v,revalidateOnlyGenerated:I,responseGenerator:c,waitUntil:o.waitUntil});if(!S)return null;if((null==N||null==(i=N.value)?void 0:i.kind)!==T.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==N||null==(l=N.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});(0,n.getRequestMeta)(e,"minimalMode")||t.setHeader("x-nextjs-cache",v?"REVALIDATED":N.isMiss?"MISS":N.isStale?"STALE":"HIT"),R&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let C=(0,E.fromNodeOutgoingHttpHeaders)(N.value.headers);return(0,n.getRequestMeta)(e,"minimalMode")&&S||C.delete(O.NEXT_CACHE_TAGS_HEADER),!N.cacheControl||t.getHeader("Cache-Control")||C.get("Cache-Control")||C.set("Cache-Control",(0,p.getCacheControlHeader)(N.cacheControl)),await (0,u.sendResponse)(b,L,new Response(N.value.body,{headers:C,status:N.value.status||200})),null};k?await i(k):await K.withPropagatedContext(e.headers,()=>K.trace(c.BaseServerSpan.handleRequest,{spanName:`${U} ${e.url}`,kind:s.SpanKind.SERVER,attributes:{"http.method":U,"http.target":e.url}},i))}catch(t){if(t instanceof N.NoFallbackError||await B.onRequestError(e,t,{routerKind:"App Router",routePath:w,routeType:"route",revalidateReason:(0,d.getRevalidateReason)({isRevalidate:P,isOnDemandRevalidate:v})}),S)throw t;return await (0,u.sendResponse)(b,L,new Response(null,{status:500})),null}}}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_7aeffcc8.js.map